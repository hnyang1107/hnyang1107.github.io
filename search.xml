<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>%2F2019%2F01%2F10%2F2019-01-10%2F</url>
    <content type="text"><![CDATA[asdsadasdasd]]></content>
  </entry>
  <entry>
    <title><![CDATA[Pandas 数据清洗]]></title>
    <url>%2F2019%2F01%2F09%2FHello-World-0%2F</url>
    <content type="text"><![CDATA[Pandas 数据清洗本文主要介绍如何查找缺失数据 用isnull检查某一列是否为缺失数据例如：1df.post_id[df.post_id.isnull()] 若指定若在整个表中出现缺失，则删除这一行 1df.dropna() 若不赋值，则不改变原来的df 若只考虑post_id这一列上，只要出现缺失数据则删除改行： 1df = df.dropna(subset=['post_id'])]]></content>
      <tags>
        <tag>Pandas</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F01%2F09%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2018%2F12%2F17%2FGit%20%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[Git 常用命令总结1、查看最近提交的日志1git log --pretty=oneline --abbrev-commit 可以得到类似下面的输出：其中左边的表示Git的commit id，是一个SHA1计算出来的一个非常大的数字，用十六进制表示，在Pycharm 2018.3.1 (Community Edition)版本之后，可以在Version Control 中看到时间线： 注意：git log只能看到以当前版本为起点的之前所有版本的信息想要看到所有的操作记录，使用git reflog 2、版本退回###2.1 退回历史版本1git reset --hard HEAD^ 此时master指向了HEAD^Git必须知道当前版本是哪个版本，在Git中，用HEAD表示当前版本，也就是最新的提交88269a...，上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100 2.2 退回未来版本首先用1git reflog 找到所有操作的历史记录左边指的是操作完之后的版本ID，要退回初始版本，则1git reset --hard 88269ab4 也可以在Pycharm中可视化操作 3、分支创建与合并3.1 dev分支创建一开始的时候，master分支是一条线，Git用master指向最新的提交，再用HEAD指向master，就能确定当前分支，以及当前分支(HEAD分支)的提交点： 当我们创建新的分支，例如dev时，Git新建了一个指针叫dev，指向master相同的提交，再把HEAD指向dev，就表示当前分支在dev上：12$ git checkout -b devSwitched to a new branch 'dev' git checkout命令加上-b参数表示创建并切换，相当于以下两条命令：123$ git branch dev$ git checkout devSwitched to branch 'dev' Git创建一个分支很快，因为除了增加一个dev指针，改改HEAD的指向，工作区的文件都没有任何变化！用git branch命令查看当前分支：123$ git branch* dev master 3.2 分支合并3.2.1 Fast forward 模式从现在开始，对工作区的修改和提交就是针对dev分支了，比如新提交一次后，dev指针往前移动一步，而master指针不变：1234$ git add readme.txt $ git commit -m "branch test"[dev b17d20e] branch test 1 file changed, 1 insertion(+) 现在，dev分支的工作完成，我们就可以切换回master分支：12$ git checkout masterSwitched to branch 'master' 假如我们在dev上的工作完成了，就可以把dev合并到master上。最简单的方法，就是直接把master指向dev的当前提交，就完成了合并：12345$ git merge devUpdating d46f35e..b17d20eFast-forward readme.txt | 1 + 1 file changed, 1 insertion(+) 3.2.2 禁用Fast forward模式在这种情况下若想保留 dev的信息，则应该用1$ git merge --no-ff -m "merge with no-ff" dev 因为生成新的路径，需要commit. 3.3 分支删除合并完分支后，甚至可以删除dev分支。删除dev分支就是把dev指针给删掉，删掉后，我们就剩下了一条master分支：12$ git branch -d devDeleted branch dev (was b17d20e). 3.4 分支策略 master分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活； 每个人都在dev分支上干活，每个人都有自己的分支，时不时地往dev分支上合并就可以了； 4、版本冲突如果遇到这种情况则Git无法执行“快速合并”，只能试图把各自的修改合并起来，Git用&lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======，&gt;&gt;&gt;&gt;&gt;&gt;&gt;标记出不同分支的内容，用git status找到冲突文件，需在冲突文件上手动修改这样才解决了冲突，用1git log --graph --pretty=oneline --abbrev-commit 可以看到分支合并情况 5、基本命令图解]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2018%2F12%2F16%2F5.%20Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[Docker常用命令总结1、Docker简介下面的图片比较了 Docker 和传统虚拟化方式的不同之处。传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程；而容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核，而且也没有进行硬件虚拟。因此容器要比传统虚拟机更为轻便。 2、获取镜像从 Docker 镜像仓库获取镜像的命令是 docker pull。其命令格式为： 1docker pull [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签] 上大校内可以搭建私人镜像仓库，方便的在校内搭建docker环境，镜像仓库mirrors.hoc.ccshu.net位于校内网络， 已经启用HTTPS，校内用户的电脑无需进行配置，连上校园网即可进行访问。 例如：1docker pull hub.hoc.ccshu.net/project/buptbbsspider:latest 对于 Docker Hub，如果不给出用户名，则默认为 library，也就是官方镜像。 3、查看镜像1docker images 4、删除镜像1docker rmi hello-world 3、运行docker有了镜像后，我们就能够以这个镜像为基础启动并运行一个容器（可以理解为一个Linux系统），例如：1docker run -it --rm hnyang/buptbbsspider /bin/bash -it：这是两个参数，一个是 -i：交互式操作，一个是 -t 终端。我们这里打算进入 bash 执行一些命令并查看返回结果，因此我们需要交互式终端。 --rm：这个参数是说容器退出后随之将其删除。默认情况下，为了排障需求，退出的容器并不会立即删除，除非手动 docker rm。我们这里只是随便执行个命令，看看结果，不需要排障和保留结果，因此使用 --rm 可以避免浪费空间。 也可以添加参数 -d使其后台运行，返回其容器ID（再进入容器用docker attach 容器ID） 注意： 就算使用了 -d 参数 然后用attach命令返回容器，再次用 exit 命令退出时，容器还是会删除，所以如果想要容器正常退出不关闭容器，请按 Ctrl+P+Q 进行退出容器]]></content>
  </entry>
</search>
