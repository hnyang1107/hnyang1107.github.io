<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[MATLAB 笔记]]></title>
    <url>%2Fposts%2F52233%2F</url>
    <content type="text"><![CDATA[矩阵基本操作将矩阵 A 列向量化：A(:)将矩阵 A B 横着合并：[A B]将矩阵 A B 竖着合并：[A; B]所有列求和：sum(A,2)画图操作标记水平轴：xlabel(&#39;time&#39;)##]]></content>
      <categories>
        <category>软件技能</category>
      </categories>
      <tags>
        <tag>MATLAB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 进阶笔记]]></title>
    <url>%2Fposts%2F47671%2F</url>
    <content type="text"><![CDATA[“An interpreted, high-level, general-purpose programming language.”函数的参数1结论：Python 中一共有五种参数类型，分别是：位置参数（必选参数）、默认参数、可变参数、关键字参数和命名关键字参数，参数定义的顺序必须是：（位置参数）必选参数、默认参数、可变参数、命名关键字参数和关键字参数。必选参数（位置参数）指的是在给函数传参数时，按照顺序，依次传值。默认参数就是在写函数的时候直接给参数传默认的值，调用的时候，默认参数已经有值，就不用再传值了。默认参数可以简化函数的调用。设置默认参数时，有几点要注意：必选参数在前，默认参数在后，否则 Python 的解释器会报错，因为如果默认参数在前传递一个新的值，由于前面的默认参数有了默认值， Python 不知道到底是更新默认参数还是给必选参数。当函数有多个参数时，把 变化大的参数放前面，变化小的参数放后面。变化小的参数就可以作为默认参数。默认参数必须指向不变对象！ 因为不变对象一旦创建，对象内部的数据就不能修改，这样就减少了由于修改数据导致的错误。此外，由于对象不变，多任务环境下同时读取对象不需要加锁，同时读一点问题都没有。我们在编写程序时，如果可以设计一个不变对象，那就尽量设计成不变对象。可变参数类与实例__str__和__repr__方法： __str__方法 print 该对象时会被调用，是给用户看的，__repr__直接输入对象查看该对象属性，是给开发看的1.廖雪峰的官方网站 ↩2.python3-cookbook ↩]]></content>
      <categories>
        <category>软件技能</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CS229 笔记【0】：机器学习中的数学]]></title>
    <url>%2Fposts%2F33591%2F</url>
    <content type="text"><![CDATA[线性代数与矩阵分析了解一定的线性代数会对机器学习有很好的理解，本章主要参考 课程补充材料 ，基本的大学线性代数知识在这里不做详细讨论，这篇笔记算是对材料做一个补充和翻译.可逆矩阵与奇异矩阵逆矩阵（inverse matrix）: 给定一个 $n$ 阶方阵 $\mathbf {A}$，若存在一 $n$ 阶方阵 $\mathbf {B}$ ，使得 $\mathbf{AB}=\mathbf{BA}=\mathbf{I}_n$，则称 $\mathbf{A}$ 是可逆的，且 $\mathbf {B}$ 是 $\mathbf{A}$ 的逆矩阵，记作 $\mathbf {A} ^{-1}$。而可逆矩阵叫做 非奇异矩阵（non-singular），在数学中，“奇异”（singular）一词用来形容破坏了某种优良性质的数学对象。对于矩阵来说，“可逆”是一个好的性质，不可逆的矩阵就称为“奇异”矩阵，可以这样按两方面简单理解，我们知道，如果一个 $n$ 阶方阵的列向量线性无关，那么这个矩阵可逆。如果一个矩阵不可逆，说明列向量线性相关，即某个列向量可以被其余列向量线性表示，而线性表示可以理解为按列向量排列的线性空间中的点具有某种“共低维（小于 $n$ 维度）空间的性质”（一个 $2\times 2$ 的矩阵不可逆表示列向量共线，一个 $3\times 3$ 方阵不可逆表示列向量共面），这样对于一个 $n$ 维空间的向量来说其实是非常 “奇异” 的，所以， 不可逆矩阵叫做一个奇异矩阵。我们也知道，若 $A$ 不可逆，则 $|A|=0$，材料中用“体积”方法直观的解释了行列式的几何意义：上图中阴影部分的面积表示了一个二阶矩阵的一个行列式的值，若这个矩阵不可逆，两个向量线性相关，说明两个向量共线，这也说明阴影部分的面积为 $0$，故 不可逆矩阵的行列式为 $0$，而二维空间中两个向量共线是非常“奇异的”，所以 不可逆矩阵叫做一个奇异矩阵。二次型与半正定矩阵对于一个方阵 $A \in \mathbb{R}^{n \times n}$ 和向量 $x \in \mathbb{R}^{n}$，标量 $x^{T} A x$ 叫做一个二次型按这种定义，则有：$$x^{T} A x=\sum_{i=1}^{n} \sum_{j=1}^{n} A_{i j} x_{i} x_{j}$$就相当于对矩阵 $A$ 所有元素都计算为二次项系数，由于对于只考虑 $i,j$ 位置的和，所以 $i,j$ 和 $j,i$ 的系数可以一分为二，故 $A$ 可以人为的构造成一个 对称矩阵，例如：$$\begin{pmatrix}x \\y\end{pmatrix}\begin{pmatrix}1 &amp; 2 \\3 &amp; 4 \\\end{pmatrix}\begin{pmatrix}x &amp; y\end{pmatrix} = x^2+5xy+4y^2 = \begin{pmatrix}x \\y \\\end{pmatrix}\begin{pmatrix}1 &amp; 5/2 \\5/2 &amp; 4 \\\end{pmatrix}\begin{pmatrix}x &amp; y\end{pmatrix}$$一个正定矩阵一定是一个可逆矩阵对于矩阵$A \in \mathbb{R}^{m \times n}$，矩阵 $G=A^{T} A$ 叫做 Gram matrix，而对于一个列满秩（“竖长的矩阵”）矩阵 $A$，$x^{T} A^{T}A x$ 是一个半正定二次型，而当 $A x=0$ 时二次型等于零，由于 $A$ 列满秩，故二次型等于零 $x$ 无解，故 Gram matrix 是个正定矩阵，即是一个可逆矩阵。一般来说把 $A$ 看做训练集，训练集中样本数远大于特征数，所以 $A$ 一般是个列满秩矩阵.特征值与特征向量给定一个 $A \in \mathbb{R}^{n \times n}$，$$A x=\lambda x, \quad x \neq 0$$ 则称 $\lambda \in \mathbb{C}$ 为矩阵 $A$ 的特征值，$x \in \mathbb{C}^{n}$ 为对应特征值的特征向量.在技术上，我们一般是通过计算 $|(\lambda I-A)|=0$ 找到其特征值与特征向量，关于特征值与特征向量，有以下一些性质：矩阵的迹等于特征向量之和：$\operatorname{tr} A=\sum_{i=1}^{n} \lambda_{i}$矩阵的行列式等于迹的乘积：$|A|=\prod_{i=1}^{n} \lambda_{i}$对角矩阵 $D=\operatorname{diag}\left(d_{1}, \ldots d_{n}\right)$ 的特征值为 $d_{1}, \ldots d_{n}$.对称矩阵的所有特征值都为实数，且其特征向量标准正交我们可以把所有的特征向量写在同一个矩阵 $X$ 中，可以写成：可以得到：$$A X=X \Lambda$$，若 $A$ 是对称矩阵，则 $U$ 是一个正交阵，$A=U \Lambda U^{T}$，可以得到：$$ x^{T} A x=x^{T} U \Lambda U^{T} x=y^{T} \Lambda y=\sum_{i=1}^{n} \lambda_{i} y_{i}^{2}$$而这一步就相当于二次型在配方，所以二次型的正定型取决于对称矩阵的特征值.矩阵微分定义 $f : \mathbb{R}^{m \times n} \rightarrow \mathbb{R}$ 是一个矩阵到实数的一个映射，$$\nabla_{A} f(A) \in \mathbb{R}^{m \times n}=\left[ \begin{array}{cccc}{\frac{\partial f(A)}{\partial A_{11}}} &amp; {\frac{\partial f(A)}{\partial A_{12}}} &amp; {\cdots} &amp; {\frac{\partial f(A)}{\partial A_{1}}} \\ {\frac{\partial f(A)}{\partial A_{21}}} &amp; {\frac{\partial f(A)}{\partial A_{22}}} &amp; {\cdots} &amp; {\frac{\partial f(A)}{\partial A_{2 n}}} \\ {\vdots} &amp; {\vdots} &amp; {\ddots} &amp; {\vdots} \\ {\frac{\partial f(A)}{\partial A_{m 1}}} &amp; {\frac{\partial f(A)}{\partial A_{m 2}}} &amp; {\cdots} &amp; {\frac{\partial f(A)}{\partial A_{m n}}}\end{array}\right]$$对于一个一个标量求梯度输出也是一个矩阵，其维数应该等于其输入的维数，所以到底谁是输入的矩阵是非常重要的，例如对于系数矩阵$A$ 和一个实向量变元$x$，对于 $\nabla f(A x)$ 可以认为输入的维数是和 $Ax$ 相同，所以输出的梯度不是一个与 $x$ 维度相等的向量，也可以认为输入的矩阵是 $x$，所以输出应该是一个矩阵，这两种方式理解都正确，类似于微积分中 $f(ax)$ 的 导数一样，要明确对谁求导数，可以这样规定：如果有下标，则对下标内的矩阵求梯度，即 $\nabla_{x} f(A x)$ 对 $x$ 求梯度，输出一个向量.若没有下标，默认对括号内求梯度，即 $\nabla f(A x)$ 输出一个维度与 $Ax$ 相等的矩阵.Hessian 矩阵与梯度类似，$$\nabla_{x}^{2} f(x) \in \mathbb{R}^{n \times n}=\left[ \begin{array}{cccc}{\frac{\partial^{2} f(x)}{\partial x_{1}^{2}}} &amp; {\frac{\partial^{2} f(x)}{\partial x_{1} \partial x_{2}}} &amp; {\cdots} &amp; {\frac{\partial^{2} f(x)}{\partial x_{1} \partial x_{n}}} \\ {\frac{\partial^{2} f(x)}{\partial x_{2} \partial x_{1}}} &amp; {\frac{\partial^{2} f(x)}{\partial x_{2}^{2}}} &amp; {\cdots} &amp; {\frac{\partial^{2} f(x)}{\partial x_{2} \partial x_{n}}} \\ {\vdots} &amp; {\vdots} &amp; {\ddots} &amp; {\vdots} \\ {\frac{\partial^{2} f(x)}{\partial x_{n} \partial x_{1}}} &amp; {\frac{\partial^{2} f(x)}{\partial x_{n} \partial x_{2}}} &amp; {\cdots} &amp; {\frac{\partial^{2} f(x)}{\partial x_{n}^{2}}}\end{array}\right]$$这个矩阵是一个对称矩阵，不能看做梯度的梯度，因为梯度本身就是一个向量，向量没法求其梯度，即个有用的结论：$\nabla_{x} b^{T} x=b$$\nabla_{x} x^{T} A x=2 A x$ 若 $A$ 是对称矩阵$\nabla_{x} x^{T} A x=(A^{T}+A) x$ 若 $A$ 是非对称矩阵$\nabla_{x}^{2} x^{T} A x=2 A$ 若 $A$ 是对称矩阵$\nabla_{A}|A|=(\operatorname{adj}(A))^{T}=|A| A^{-T}$$\nabla_{A} \log |A|=\frac{1}{|A|} \nabla_{A}|A|=A^{-1}$(用到了链式法则)$\nabla_{A} \operatorname{tr} A B=B^{T}$$\nabla_{A^{T}} f(A)=\left(\nabla_{A} f(A)\right)^{T}$$\nabla_{A} \operatorname{tr} A B A^{T} C=C A B+C^{T} A B^{T}$参考资料《矩阵分析与应用（第二版）张贤达》]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>数学</tag>
        <tag>cs229</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CS229 笔记【1】：回归算法]]></title>
    <url>%2Fposts%2F41333%2F</url>
    <content type="text"><![CDATA[“A broad introduction to machine learning and statistical pattern recognition”一些记号说明$m$ = # training exmples.(训练样本个数，表的行数)$n$ = # features.(特征个数，表的列数)$\mathcal{X}$ = “input” variables/ fratures.(整张表)$\mathcal{Y}$ = “output” variables/ “target” variables（某一列）$(x,y)$ = “training example”$(x^{(i)},y^{(i)})$ = 第 $i$ 个训练样本. (表的某一行)在学习的过程中，学习算法试图通过训练数据集中的样本产生一个可以预测 $y$ 的预测系统，这个过程就叫做机器学习。线性回归对于线性回归，我们假设参数和输入的特征服从线性函数，也就是说$$h(x)=\sum_{i=0}^{n} \theta_{i} x_{i}=\theta^{T} x$$这里假定 $x_0=1$，定义其损失函数为偏离输出变量的平方和，也就是$$J(\theta)=\frac{1}{2} \sum_{i=1}^{m}\left(h_{\theta}\left(x^{(i)}\right)-y^{(i)}\right)^{2}$$]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>CS229</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NetworkX 笔记]]></title>
    <url>%2Fposts%2F53355%2F</url>
    <content type="text"><![CDATA[“A Python package for complex networks”网络的基本属性连通性：判断是否连通：nx.is_connected(G)取网络中最大连通子图：G = max(nx.connected_component_subgraphs(G), key=len)给网络、节点、连边增加属性给整个网络增加属性 ：在网络生成时给网络增加属性：G = nx.Graph(day=&quot;Friday&quot;)在网络生成之后修改网络属性：G.graph[&#39;day&#39;] = &quot;Monday&quot;显示网络属性：G.graph给点增加属性 ：在网络生成时添加点属性：G.add_node(1, time=&#39;5pm&#39;)、G.add_nodes_from([3], time=&#39;2pm&#39;)(因为有一个关键字参数 **attr)在网络生成之后修改点属性：G.nodes[1][&#39;room&#39;] = 714显示点属性：G.nodes.data()二分图由于 NetworkX 没有一个自定义的二分图类型，所以所有的二分图都是 Graph() 或者 DiGraph() 类型，详细内容可参考 Bipartite检测图的二分性：networkx.is_bipartite()####]]></content>
      <categories>
        <category>软件技能</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>NetworkX</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Pandas 常用核心函数与方法]]></title>
    <url>%2Fposts%2F55796%2F</url>
    <content type="text"><![CDATA[“A powerful Python data analysis toolkit”当前 Pandas 版本为 0.24.1数据选取、索引、采集.loc：利用索引定位，必须输入索引，输入索引不存在时会报错.iloc：i 表示 integer position，利用整数位置进行定位若用 df.loc、 df.iloc 或者 df[&#39;col&#39;] 选取子集，是选取了原来 dataframe 的视图而不是副本，修改这个子集会修改原来的 dataframe ，所以要选取副本，再加上 .copy() 可创建副本，有时候 Pandas 会抛出 SettingWithCopyWarning 的警告，绝大部分是因为副本视图问题造成的。选取多行：df.loc[[index_name1,index_name2]]选取多列：df[[col_name1, col_name2]]正则表达式选取：df[&#39;new_col&#39;] = df[&#39;col&#39;].str.extract(&#39;regex&#39;) 按照 regex 正则表达式选取 col 列中每一元素，结果保存在 new_col ，查看更多请点击 pandas.Series.str.extract正则表达式替换文本：df[&#39;col&#39;].str.replace(&#39;text&#39;,&#39;&#39;)（将 text 文本替换为空文本，即删除特定的字符），关于字符串操作，可以参考 python3-cookbook查找缺失数据：df.isnull()：对整个 df 判断是否为空，返回一张大表，这张表每个元素为布尔值，True 则为空值.判断某一列（行）是否存在缺失值：df.loc[&#39;index&#39;].isnull().any()，存在则返回 True，不存在则返回 False.对于数据很大的表，用 df.isnull() 不方便看到缺失值的具体位置，配合 pandas.Series.any() 函数可以确定某一行或者某一列出现缺失值，（axis=0: index,axis=1: columns），any() 方法表示判断给定的 Series 是否全部为 False ，若全为 False 则返回 False，如果有一个为 True，则返回 True，所以当返回 True 表示这一行或者这一列有缺失值判断某行（列）是否存在缺失数据：df.loc[&#39;index&#39;].isnull().any()行循环：for index, row in df.iterrows():数据修改、删除、映射生成一个数据表：df = pd.DataFrame(data={&#39;col1&#39;:[1,2,3],&#39;col2&#39;:[4,5,6]})增加一行：df.loc[&#39;new_raw&#39;] = &#39;1&#39;增加一列：df[&#39;new_colu&#39;]=&#39;1&#39;.按上面两种方式选取的子集为原来 df 的视图.删除一行：df.drop(&#39;raw_name&#39;, axis=0, inplace=True)，这里默认 drop 返回原 df 的视图，若设置 inplace=True 则修改 df 返回 None.删除一列：df.drop(&#39;raw_name&#39;, axis=1, inplace=True)删除缺失数据：df.dropna(axis=0, how=&#39;any&#39;, inplace=False, subset=[&#39;col&#39;]). axis=0 表示检查这一行，按照 how=&#39;any&#39; (这一行只要出现了缺失，就删除)的方法删除这一行，subset=[&#39;col&#39;] 表示只检查 col 这一列是否有缺失值，inplace=False 表示删除后不替换原来的变量.修改列(行)名称：df.rename(columns={&#39;old_col_name&#39;: &#39;new_col_name&#39;}, index={&#39;old_index_name&#39;: &#39;new_index_name&#39;},inplace=True)修改索引列名称：上面的方法无法改变索引列的名称，可以用 df.index.name = &#39;new_name&#39; 的方法.凡是输入后返回一张表，说明原来带有 inplace 参数，如需替换则设置为 True修改索引：reset_index() ，也可以将 MultiIndex 转换成普通的 Index.对索引排序：df.sort_index()，默认返回排序后的 df，可设置 inplace 参数.数据合并、连接、关系Concat 与 Append 操作Merge 操作Group By 技术Pandas 提供了一个灵活高效的 groupby 功能，可以对某些标签或索引的局部进行累计分析，很多复杂的操作都可以化为 GroupBy 操作(不能保证是效率最高的).手册上对于 GroupBy 主要可以分为以下三个步骤：分割-应用-组合Splitting the data into groups based on some criteria.Applying a function to each group independently.Combining the results into a data structure.上图表现了这种过程，而中间的分割过程不需要显式地暴露出来，这一点十分重要。而且 GroupBy(经常)只需要一行代码， 就可以计算每组的和、均值、计数、最小值以及其他累计值。GroupBy 的用处就是将这些步骤进行抽象: 用户不需要知道在底层如何计算，只要把操作看成一个整体就够了.分割In [1]: df = pd.DataFrame(&#123;'X': ['A', 'B', 'A', 'B'], 'Y': [1, 4, 3, 2]&#125;)In [2]: dfOut[2]: X Y0 A 11 B 42 A 33 B 2In [3]: df.groupby(['X'])Out[3]: &lt;pandas.core.groupby.groupby.DataFrameGroupBy object at 0x1144ea198&gt;可以看到，这里的返回值不是一个 DataFrame 对象，而是一个 DataFrameGroupBy 对象。 这个对象的魔力在于，你可以将它看成是一种特殊形式的 DataFrame，里面隐藏着若干组 数据，但是在没有应用累计函数之前不会计算。GroupBy 对象是一种非常灵活的抽象类型。在大多数场景中，可以将它看成是 DataFrame 的集合.默认情况下，GroupBy 对象会对 group keys 进行排序，如果分的组过多，可以设置 groupby([&#39;X&#39;], sort=False) 提高运行速度.默认情况下对多列进行 GroupBy 会产生 MultiIndex，可以设置 as_index=False 取消生成 MultiIndex，也可以用 .reset_index() 来实现.利用 get_group(&#39;group_name&#39;) 方法获得某一分组的 DataFrame，还可以利用 .groups 属性获得包含所有分组的字典，字典的键为组名，例如：In [27]: df.groupby('A').groupsOut[27]: &#123;'bar': Int64Index([1, 3, 5], dtype='int64'), 'foo': Int64Index([0, 2, 4, 6, 7], dtype='int64')&#125;这个属性可以用于组的循环：In [57]: grouped = df.groupby('A')In [58]: for name, group in grouped: ....: print(name) ....: print(group) ....: bar A B C D1 bar one 0.254161 1.5117633 bar three 0.215897 -0.9905825 bar two -0.077118 1.211526foo A B C D0 foo one -0.575247 1.3460612 foo two -1.143704 1.6270814 foo two 1.193555 -0.4416526 foo one -0.408530 0.2685207 foo three -0.862495 0.024580应用累计与求和最常用的方法有 .sum() 和 .size()，.sum() 是对其余所有数值型的列全部求和，.size() 是只计算聚合的列的个数。若对多列进行聚合，默认会把将要聚合的列当做一个 MultiIndex，这是因为在 groupby 的时候包含一个默认属性 as_index=True 这样的好处有两点：加快运算速度方便进一步的操作举例来说：In [13]: df = pd.DataFrame(data = &#123;1:['a','a','b','c','a'],2:['b','b','a','d','c ...: '],3:[1,1,1,1,1]&#125;)In [14]: dfOut[14]: 1 2 30 a b 11 a b 12 b a 13 c d 14 a c 1In [19]: df.groupby([1,2]).sum()Out[19]: 31 2a b 2 c 1b a 1c d 1In [20]: df.groupby([1,2],as_index=False).sum()Out[20]: 1 2 30 a b 21 a c 12 b a 13 c d 1而利用 reset_index() 可以达到同样的效果：In [24]: df.groupby([1,2]).sum().reset_index()Out[24]: 1 2 30 a b 21 a c 12 b a 13 c d 1但是对于 .size() 来说，设置 reset_index()=False 并没有效果，还是需要用 reset_index()，实际上，DataFrameGroupBy 对象 内置的.size() 方法返回的是一个 Series 对象而不是 DataFrameIn [18]: df.groupby([1,2],as_index=False).size() # 依旧是 MultiIndexOut[18]:1 2a b 2 c 1b a 1c d 1dtype: int64In [25]: df.groupby([1,2]).size().reset_index()Out[25]: 1 2 00 a b 21 a c 12 b a 13 c d 1若要将统计的 size 成为新的一列，可以使用 .to_frame 方法生成新的一列： df = df.groupby([&#39;A&#39;,&#39;B&#39;]).size().to_frame(&#39;size&#39;)转换与应用apply() 方法让你可以在每个组上应用任意方法。这个函数输入一个 DataFrame，返回一个 Pandas 对象（ DataFrame 或 Series ）或一个标量（ scalar，单个数值），新版的 Pandas 可以 放入 apply 的参数，例如：df.apply(f,alpha=0.1)-[]这里开始拾遗axis 取 0 还是 1？axis=1 表示按照行（index）的方向来，也就是说函数的输入为每一行，同理，axis=0 表示按照列（column）的方向来，也就是说函数的输入为每一列。df.apply() 输入 0 表示 apply 到每一列上去，输入 1 表示 apply 到每一行上去。sum(axis=1) 表示按行求和，sum(axis=0) 表示按列求和drop(axis = 1) 删除列正则表达式从开头匹配：表达式最前面加上^匹配年份：(?!0000)[0-9]{4}字符串Series.str 可以广播某一字符串方法，适用于整个列或者行，而避免用 apply 函数.在某一列寻找包含某一字符串 &#39;str&#39; 的数据：df[df[&#39;content&#39;].str.contains(&#39;str&#39;, na=False)]，由于 contains 返回布尔型数据，前面要再加上一个 df, na=False 表示若遇到缺失数据返回 False.strip() 方法能用于删除开始或结尾的字符。 lstrip() 和 rstrip() 分别从左和从右执行删除操作。 默认情况下，这些方法会去除空白字符，但是你也可以指定其他字符.时间序列操作生成固定日期的时间序列：pd.date_range生成固定时间段的时间序列：pd.date_rangeKaggle 数据竞赛常用命令pandas.Series.factorize()：返回一个 tuple，对于数据的某一列为种类属性，将里面的类别映射成数字:1234567In [0]: labels, uniques = pd.factorize(['b', 'b', 'a', 'c', 'b'])In [1]: labelsOut[1]: array([0, 0, 1, 2, 0])In [2]: uniquesOut[2]: array(['b', 'a', 'c'], dtype=object)这个命令一般用于数据探索阶段，例如当给定的数据不知道是否为 categoril 类型的数据时，可以先进行一个映射：123# Label encoderfor c in train.columns[train.dtypes == 'object']: X[c] = X[c].factorize()[0]]]></content>
  </entry>
  <entry>
    <title><![CDATA[Jupyter Notebook 使用方法记录]]></title>
    <url>%2Fposts%2F54421%2F</url>
    <content type="text"><![CDATA[“A web-based application suitable for capturing the whole computation process.”Jupyter Notebook 简介Jupyter Notebook（此前被称为 IPython notebook）是一个交互式笔记本，而 Jupyter这个名字是它要服务的三种语言的缩写：Julia，Python 和 R，这个名字与 “木星（Jupiter）” 谐音。而 Jupyter Notebook 最早是为了支持 Python 设计的，目前为止支持运行 40 多种编程语言。其本质是一个 Web 应用程序，便于创建和共享程序文档，支持实时代码的运行。而且非常适合用来做流式的数据分析和尝试性的程序编写。而在普通的 Python shell 或者在 IDE（集成开发环境）如 Pycharm 中写代码会显得更加繁琐。作为一个 Web 应用程序，还可以实现远程服务器访问，也就是说可以配置jupyter 服务器来实现远程浏览器登录，还可以支持多人团队的 Jupyter Hub 实现服务器资源分配，关于 jupyter 远程登录可以参考这篇文章，前提是服务器必须有公网 IP，若没有，可以参考各种内网穿透的方法。作为 Web 服务器，若 8888 端口没有占用，Jupyter Notebook 会默认将 8888 设定为通信端口，若占用，则会将端口号 +1，有的时候在 shell 内无法停止端口占用，可以手动停止端口占用以免浪费端口。这里以 Windows 为例：例如要停止 8889 端口，则可以在 cmd 下输入 netstat -aon|findstr &quot;8889&quot; 找到对应的 PID，然后在任务管理器下结束对应 PID 的进程，即可完成端口释放。另外，Jupyter Notebook 非常适合作为教学工具，因为 markdown 的支持极大地丰富了文字表现力，现在 也有人将技术教学视频“翻译”成可执行的 .ipynb 文档，在类 IDE 环境中边看视频边实操运行代码。如 Mo 平台笔记本扩展功能笔记本扩展（nbextensions）是一种 JavaScript模块，可以加载到笔记本前端页面上，可以大大提升效率。安装时需要用到conda：conda install -c conda-forge jupyter_nbextensions_configurator总之，安装合适的扩展功能可以极大地方便代码书写。Jupyter NoteBook 的快捷键Jupyter在顶部的菜单里保留了许多快捷键：Help &gt; keyboard Shortcuts. 每次更新Jupyter时，都值得再次进行查看，因为新的快捷键总是不断被添加进来。查看快捷键的方式是使用命令面板：Cmd + Shift + P （或者 Linux 和Windows上 Ctrl+ Shift + P）Jupyter Notebook 有两种键盘输入模式。即命令模式和编辑模式，这与 Vim 有些类似。在编辑模式下，可以往单元中键入代码或文本，此时单元格被绿色的框线包围，且命令模式下的快捷键不生效。在命令模式下，可以用快捷键命令运行单元格，移动单元格，切换单元格编辑状态等等，此时的单元格被灰色的框线包围，且编辑模式下的快捷键不生效。从命令模式进入编辑模式需按 Enter 键，从编辑模式切换到命令模式需按 Esc 键。命令模式快捷键（按 `Esc` 键开启）:在当前 cell 下方创建新的 cell：A在当前 cell 上方创建新的 cell：B删除选中的单元：连续按两个 D进入 Markdown 状态：M恢复最后一个被删除的 cell：Z编辑模式快捷键（ 按 Enter 键启动）:给出当前函数提示：Shift + Tab注释（反注释）当前的代码行：Ctrl + /删除当前光标的全部文字：Command + DeleteJupyter Magic常用的 Jupyter Magic 魔法方法总结%load test.py：将当前路径下 test.py 载入到 jupyter 的当前 cell 中%reset -f：清除所有已经定义过的变量%%writefile filename.py：写在 cell 的开头，运行时保存为 filename.py 文件，路径默认为当前工作路径cell 内画图：%matplotlib inline使得 cell 内输出图形为矢量图：%config InlineBackend.figure_format = &#39;svg&#39;%store data: 保存 data 变量到磁盘，可以用在不同的 NoteBook 之间传递变量，适合短期保存（可 pickle 化的）数据%store: 查看已保存的变量%store -r: 从磁盘里已保存好的文件更新现在所有的变量，会覆盖当前同名的变量%store -r data: 更新覆盖某一个变量%store -d data: 移除已保存的 data%store -z: 移除全部保存的的变量变量保存在 ~/.ipython/profile_default/db/autorestore/&lt;variable_name&gt; ，~ 指 home 文件夹，并不适合用于资料的长期保存，可能会受到版本迭代的影响.利用魔法命令进行 Python 代码分析%timeit: 对某一行语句多次重复计算代码运算时间，多于较慢的命令会自动调整重复次数，其中在底层做了一些聪明的事情来阻止系统的垃圾回收，所以 %timeit 通常比 %time 得到更短的时间%time: 对某一行语句多次重复计算代码运算时间，主要关心 Wall time%%timeit、%%time: 对整个代码块计时%prun: 对每行单独计算时间分析，返回时间统计表%who_ls: 查看当前命名空间内的全部变量%reset_selective -f regex: 清除变量名称符合正则表达式的变量，-f 表示不询问强制执行.%reset -f : 清除所有变量升级到 Jupyter Lab！JupyterLab 是 Jupyter Notebook 的下一代产品，集成了更多功能。越来越像一个 类似于 MATLAB 的 IDE，目前开发到 0.35 版本，已经可以使用而且非常强大，据官网说法，当 1.0.0 版本出来之时，就会取代 jupyter notebook.将服务器升级为 Jupyter Lab 非常简单，只需要在服务器上安装好后在shell 内输入 jupyter lab, 原来 Notebook 的设置完全不改变，远程输入服务器地址即可访问 Jupyter Lab.Jupyter Lab 无法兼容原来 NoteBook 的插件，需要额外安装 Jupyter Lab 插件，更多插件请参考 Jupyter RenderersNotes:查看所安装的插件可以运行 jupyter labextension list卸载某插件可以用 jupyter labextension uninstall，例如：jupyter labextension uninstall @jupyterlab/plotly-extension1.[译] 27 个 Jupyter Notebook的小提示与技巧 | Focus on ML &amp; DM ↩2.Jupyter Notebook的27个秘诀，技巧和快捷键 | 作业部落 Cmd Markdown 编辑阅读器 ↩3.JupyterLab插件 | RexKing6’s Note ↩]]></content>
      <tags>
        <tag>Jupyter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo 文字排版全纪录]]></title>
    <url>%2Fposts%2F40915%2F</url>
    <content type="text"><![CDATA[“再好的表达能力也需要精致的排版技巧”为什么使用 Hexo 排版hexo 是使用 Markdown 语言作为主要书写语言，其目的是通过简单、易读易写的文本格式生成结构化的 HTML 文档，所以 Markdown 是兼容 HTML 的。虽然一些基本的语法在各种 Markdown 书写软件是支持的，但是不同的软件支持的广度又不一样，例如 Github Flavored Markdown (GFM) 语法不支持 Markdown 注脚，这会造成易用性的困难，Hexo 可以很好地解决这个排版问题，例如可以通过安装相应的插件实现。这里推荐 Markdown 软件 MWeb，可以很好的支持静态博客的生成，还可以将笔记发布到印象笔记，可以说非常方便。利用 hexo server 进入调试模式，左边网页实时渲染 control+R 刷新，右边 书写 Markdown control+S 保存，必要时可以利用移动设备局域网下访问站点或利用 Chrome 调试成移动端观察渲染效果。也有人将这种写作方式制作成一个后端管理工具，例如 hexo admin，不过相比直接网页渲染，所支持的渲染效果并不好.2019-03-20 更新！在 VSCode 面前，一切都是那么的弱小！Hexo 文章模板文件如果你是在站点文件夹根目录用 hexo new post &lt;title&gt; 新建的文章，那么其实它就是将文章的模版文件 post.md「复制」了一份到 ~/blog/source/_posts/ 下，所以这也意味着：你可以通过命令行的方式创建模板样式的 .md 文件。你可以直接通过在 ~/blog/source/_posts/ 下新建 .md 结尾的文件来写新的文章。为了美观起见，英文和中文之间必须添加空格首先这里附上我的模板文件文件位置：~/hexo/blog/scaffolds/post.md1234567891011121314151617181920212223---title: &#123;&#123; title &#125;&#125;date: &#123;&#123; date &#125;&#125;permalink:categories:tags: []description:mathjax: ---&lt;p class="description"&gt;&lt;/p&gt;&lt;img src="" alt="" style="width:85%" /&gt;&lt;!-- more --&gt;######&lt;hr /&gt;&#123;% note success no-icon %&#125; &lt;center&gt;本文更新于 &lt;/center&gt;&#123;% endnote %&#125;Tips: 这个地方写作时若直接插入上面 Markdown 代码，{{ title }}、{{ date }} 的部分会被转义，所以应该在代码中间插入 {% raw %}{% endraw %} 防止被转义。下面逐一解释上述模板文件以 ---分隔的区域，叫做 Front-matter ，是用于指定此文件所包含的变量，具体变量实现可以百度搜索了解Hexo 会自动识别 &lt;!-- more --&gt; 部分为摘要，也就是表现在首页部分，一般来说，为了美观起见，首页都是一句话加上一张图片排版，这句话写在 &lt;p&gt;&lt;/p&gt; 标签内，src 插入图片的 url 链接。正文中所有的标题都是从二级标题开始。最后插入 &lt;hr /&gt; 横线表示文章结束，从后面可以插入参考文献。最后插入本文的修改时间，技术总是会随着时间更新，提示读者本文的最后修改时间。当然，文章摘要还需要在 _custom.styl 下插入一些自定义 CSS 样式，代码如下：文件位置：~/hexo/blog/themes/next/source/css/_custom/custom.styl12345678910111213141516+ // 文章的描述description+ .posts-expand .post-meta .post-description &#123;+ font-style: italic;+ font-size: 14px;+ margin-top: 30px;+ margin-bottom: 0px;+ color: #666;+ &#125;+ // 自定义替代description的样式+ p.description&#123;+ text-align: center;+ font-size: 14px;+ font-style: italic;+ color: #666;+ margin-top: 30px;+ &#125;红色 - 和绿色 + 的样式哪来的？哈哈哈，原来这也是一种语言，叫 diff，所以你只需在 [language] 这写 diff，然后在相应代码前面加上 - 和 + 就行了。不过默认的 - 是绿色，+ 是红色，与 GitHub 上相反，别扭就自己改成 GitHub 的，在 custom.styl 加入以下代码文件位置：~/hexo/blog/themes/next/source/css/_custom/custom.styl1234567+ // 文章```代码块diff样式+ pre .addition &#123;+ background: #e6ffed;+ &#125;+ pre .deletion &#123;+ background: #ffeef0;+ &#125;段内文字格式Hexo 中基本的 Markdown 语法手册可以参考这篇博文 Hexo Markdown 简明语法手册 | Mobilicorpus，如果有些用 Markdwon 的语法却达不到预期效果（甚至产生奇怪的 bugs），或者用 Markdwon 的语法无法实现，这时就可以考虑用 HTML 和 CSS。下面是比较常见的，难以用 Markdwon 的语法实现的 HTML 语言：样式代码效果分隔线&lt;hr /&gt;引用&lt;blockquote&gt;引用内容&lt;/blockquote&gt;引用内容更宽的引用&lt;p&gt;&lt;blockquote&gt;引用内容&lt;/blockquote&gt;&lt;/p&gt;引用内容居中&lt;center&gt;内容&lt;/center&gt;内容右对齐&lt;p style=&quot;text-align:right&quot;&gt;内容&lt;/p&gt;内容左对齐&lt;p style=&quot;text-align:left&quot;&gt;内容&lt;/p&gt;内容字体大小和颜色1&lt;font color=&quot;red&quot; size=&quot;1&quot;&gt;内容&lt;/font&gt;内容黄色荧光笔&lt;mark&gt;内容&lt;/mark&gt;内容Bootstrap Callout2本站用的是 Next 主题，其配备了一些自带的主题样式，需要在主题配置文件 中开启：文件位置：~/hexo/blog/themes/next/config123456789101112note: # Note tag style values: # - simple bs-callout old alert style. Default. # - modern bs-callout new (v2-v3) alert style. # - flat flat callout style with background, like on Mozilla or StackOverflow. # - disabled disable all CSS styles import of note tag. style: simple icons: false border_radius: 3 # Offset lighter of background in % for modern and flat styles (modern: -12 | 12; flat: -18 | 6). # Offset also applied to label tag variables. This option can work with disabled note tag. light_bg_offset: 0可以获得类似 beamer 中的 block 样式：This is a notenote textnote text代码如下：&#123;% note danger %&#125;#### This is a notenote textnote text&#123;% endnote %&#125; 注意可以在 danger 后面加上 no-icon 实现去掉旁边的 icon，这个地方我用了四级标题 ####，避免歧义，左侧导航栏没有显示，在主题配置文件 toc 选项可以修改，同样，在附上这段代码时,同样加上 {% raw %}{% endraw %}，防止被转义。还有一种 label 样式，所谓的 label 从效果上看神似荧光笔，例如：这是default这是primary这是success这是info这是warning这是danger这是有删除线的danger相应的代码：1234567&#123;% label default@default%&#125;&#123;% label primary@primary%&#125;&#123;% label success@success%&#125;&#123;% label info@info%&#125;&#123;% label warning@warning%&#125;&#123;% label danger@danger%&#125;~~&#123;% label danger@danger%&#125;~~ 代码格式在主题配置文件可以开启代码自动高亮功能，代码按照以下格式给出123&#123;% codeblock [title] [lang:language] [url] [link text] [line_number:(true|false)] [highlight:(true|false)] [first_line:number] [mark:#,#-#] %&#125;YOUR CODE HERE&#123;% endcodeblock %&#125; title 是代码名称，一般为此段代码所在的文件路径；language 是代码语言的名称，用来设置代码块颜色高亮，纯文本用 plain；url 是文件所在的超链接地址；link text 如它的字面意思，超链接的名称；注意：这四个参数都不是必须的，若不指定代码语言开启自动高亮后则会自动为代码高亮更多内置标签插件样式参考 标签插件段间排版对于中文排版，常用的排版方式分为两种，一种是首段空两格，段间距等于行间距，这种方式叫做段首缩排（下图左一）。还有一种是段首不进行缩进，段间距大于行间距，叫做段间距式（下图左二）。书籍印刷的表现要求是专注文字内容，因此阅读体验应当置于美观之上。由于段间距比段首缩排的分离程度更大，一字连一字阅读时易产生隔阂感、停顿感，故段首缩排与之相比更为优雅，有着更好的阅读体验。对于网页，与纸质书的翻页不同，它是竖直方向的连续滚动。当网页快速滚动时，就使段落上下相连的段首缩排显得繁密易懵，而段落上下间隔的段间距则显得结构简明。段首缩排在快速滚动的互联网时代显得混乱与不整齐，段间距也就比段首缩排更适合于网页，因为它更利于快速传达信息。千万不要同时用段首缩排和段间距！(上图右一)，技术类文章用段间距排版（左二），文学类的文章用段首缩排（左一）！1.HTML 标签 | w3school ↩2.Note (Bootstrap Callout) | NexT ↩3.打造个性超赞博客Hexo+NexT+GitHubPages的超深度优化 | reuixiy ↩]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
