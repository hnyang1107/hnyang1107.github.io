<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Pandas 常用核心函数与方法]]></title>
    <url>%2F2019%2F02%2F20%2FPandas-%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[A powerful Python data analysis toolkit当前 Pandas 版本为 0.24.1数据选取、索引、采集.loc for label based indexing利用索引定位，必须输入索引，输入索引不存在时会报错.iloc for positional indexing i 表示 integer position，利用整数位置进行定位若用 .loc 或者 .iloc 选取子集，是选取了原来 dataframe 的视图而不是副本，修改这个子集会修改原来的 dataframe ，所以要选取副本，再加上 .copy() 可创建副本，有时候 Pandas 会抛出 SettingWithCopyWarning 的警告，绝大部分是因为副本视图问题造成的。选取多行：df.loc[[index_name1,index_name2]]选取多列：df[[col_name1, col_name2]]正则表达式选取：df[&#39;new_col&#39;] = df[&#39;col&#39;].str.extract(&#39;regex&#39;) 按照 regex 正则表达式选取 col 列中每一元素，结果保存在 new_col , 查看更多请点击 pandas.Series.str.extract查找缺失数据：df.isnull()：对整个 df 判断是否为空，返回一张大表，这张表每个元素为布尔值，True 则为空值.判断某一列（行）是否存在缺失值：df.loc[&#39;index&#39;].isnull().any()，存在则返回 True，不存在则返回 False.对于数据很大的表，用 df.isnull() 不方便看到缺失值的具体位置，配合 pandas.Series.any() 函数可以确定某一行或者某一列出现缺失值，（axis=0: index,axis=1: columns），any() 表示只要出现缺失值就删除，当返回 True 表示这一行或者这一列有缺失值判断某行（列）是否存在缺失数据：df.loc[&#39;index&#39;].isnull().any()数据修改增加一行：df.loc[&#39;new_raw&#39;] = &#39;1&#39;增加一列：df[&#39;new_colu&#39;]=&#39;1&#39;按上面两种方式选取的子集为原来 df 的视图.删除一行：df.drop(&#39;raw_name&#39;, axis=0, inplace=True)，这里默认 drop 返回原 df 的视图，若设置 inplace=True 则修改 df 返回 None.删除一列：df.drop(&#39;raw_name&#39;, axis=1, inplace=True)删除缺失数据：df.dropna(axis=0, how=&#39;any&#39;, inplace=False, subset=[&#39;col&#39;]). axis=0 表示检查这一行，按照 how=&#39;any&#39; (这一行只要出现了缺失，就删除)的方法删除这一行，subset=[&#39;col&#39;] 表示只检查 col 这一列是否有缺失值，inplace=False 表示删除后不替换原来的变量.修改列(行)名：df.rename(columns={&#39;old_col_name&#39;: &#39;new_col_name&#39;}, index={&#39;old_index_name&#39;: &#39;new_index_name&#39;},inplace=True)修改索引列名称：上面的方法无法改变索引列的名称，可以用 df.index.name = &#39;new_name&#39; 的方法.拾遗axis 取 0 还是 1？axis=1 表示按照行（index）的方向来，也就是说函数的输入为每一行，同理，axis=0 表示按照列（column）的方向来，也就是说函数的输入为每一列。注意 df.apply() 输入 0 表示 apply 到每一列上去，输入 1 表示 apply 到每一行上去。正则表达式从开头匹配：表达式最前面加上^匹配年份：(?!0000)[0-9]{4}在某一列寻找包含某一字符串 &#39;str&#39; 的数据：df[df[&#39;content&#39;].str.contains(&#39;str&#39;, na=False)]，由于 contains 返回布尔型数据，前面要再加上一个 df, na=False 表示若遇到缺失数据返回 False.]]></content>
  </entry>
  <entry>
    <title><![CDATA[Jupyter Notebook 使用方法记录]]></title>
    <url>%2F2019%2F02%2F20%2FJupyter-Notebook-%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[A web-based application suitable for capturing the whole computation process.Jupyter Notebook 简介Jupyter Notebook（此前被称为 IPython notebook）是一个交互式笔记本，而 Jupyter这个名字是它要服务的三种语言的缩写：Julia，PYThon 和 R，这个名字与 “木星（Jupiter）” 谐音。而 Jupyter Notebook 最早是为了支持 Python 设计的，目前为止支持运行 40 多种编程语言。其本质是一个 Web 应用程序，便于创建和共享程序文档，支持实时代码的运行。而且非常适合用来做流式的数据分析和尝试性的程序编写。而在普通的 Python shell 或者在 IDE（集成开发环境）如 Pycharm 中写代码会显得更加繁琐。作为一个 Web 应用程序，还可以实现远程服务器访问，也就是说可以配置jupyter 服务器来实现远程浏览器登录，还可以支持多人团队的 Jupyter Hub 实现服务器资源分配，关于 jupyter 远程登录可以参考这篇文章，前提是服务器必须有公网 IP，若没有，可以参考各种内网穿透的方法。作为 Web 服务器，若 8888 端口没有占用，Jupyter Notebook 会默认将 8888 设定为通信端口，若占用，则会将端口号 +1，有的时候在 shell 内无法停止端口占用，可以手动停止端口占用以免浪费端口。这里以 Windows 为例：例如要停止 8889 端口，则可以在 cmd 下输入 netstat -aon|findstr &quot;8889&quot; 找到对应的 PID，然后在任务管理器下结束对应 PID 的进程，即可完成端口释放。另外，Jupyter Notebook 非常适合作为教学工具，因为 markdown 的支持极大地丰富了文字表现力，现在 也有人将技术教学视频“翻译”成可执行的 .ipynb 文档，在类 IDE 环境中边看视频边实操运行代码。如 Mo 平台笔记本扩展功能笔记本扩展（nbextensions）是一种 JavaScript模块，可以加载到笔记本前端页面上，可以大大提升效率。安装时需要用到conda：conda install -c conda-forge jupyter_nbextensions_configurator总之，安装合适的扩展功能可以极大地方便代码书写。Jupyter NoteBook 的快捷键Jupyter在顶部的菜单里保留了许多快捷键：Help &gt; keyboard Shortcuts. 每次更新Jupyter时，都值得再次进行查看，因为新的快捷键总是不断被添加进来。查看快捷键的方式是使用命令面板：Cmd + Shift + P （或者 Linux 和Windows上 Ctrl+ Shift + P）Jupyter Notebook 有两种键盘输入模式。即命令模式和编辑模式，这与 Vim 有些类似。在编辑模式下，可以往单元中键入代码或文本，此时单元格被绿色的框线包围，且命令模式下的快捷键不生效。在命令模式下，可以用快捷键命令运行单元格，移动单元格，切换单元格编辑状态等等，此时的单元格被灰色的框线包围，且编辑模式下的快捷键不生效。从命令模式进入编辑模式需按 Enter 键，从编辑模式切换到命令模式需按 Esc 键。命令模式快捷键（按 `Esc` 键开启）:在当前 cell 下方创建新的 cell：A在当前 cell 上方创建新的 cell：B删除选中的单元：连续按两个 D进入 Markdown 状态：M恢复最后一个被删除的 cell：Z编辑模式快捷键（ 按 Enter 键启动）:给出当前函数提示：Shift + Tab注释（反注释）当前的代码行：Ctrl + /删除当前光标的全部文字：Command + DeleteJupyter Magic常用的 Jupyter Magic 魔法方法总结%load test.py：将当前路径下 test.py 载入到 jupyter 的当前 cell 中%reset -f：清除所有已经定义过的变量%%writefile filename.py：写在 cell 的开头，运行时保存为 filename.py 文件，路径默认为当前工作路径cell 内画图：%matplotlib inline使得 cell 内输出图形为矢量图：%config InlineBackend.figure_format = &#39;svg&#39;%store data: 保存 data 变量到磁盘，可以用在不同的 NoteBook 之间传递变量，适合短期保存（可 pickle 化的）数据%store: 查看已保存的变量%store -r: 从磁盘里已保存好的文件更新现在所有的变量，会覆盖当前同名的变量%store -r data: 更新覆盖某一个变量%store -d data: 移除已保存的 data%store -z: 移除全部保存的的变量变量保存在 ~/.ipython/profile_default/db/autorestore/&lt;variable_name&gt; 路径下，并不适合用于资料的长期保存，可能会受到版本迭代的影响.升级到 Jupyter Lab！JupyterLab 是 Jupyter Notebook 的下一代产品，集成了更多功能。越来越像一个 类似于 MATLAB 的 IDE，目前开发到 0.35 版本，已经可以使用而且非常强大，据官网说法，当 1.0.0 版本出来之时，就会取代 jupyter notebook.将服务器升级为 Jupyter Lab 非常简单，只需要在服务器上安装好后在shell 内输入 jupyter lab, 原来 Notebook 的设置完全不改变，远程输入服务器地址即可访问 Jupyter Lab.Jupyter Lab 无法兼容原来 NoteBook 的插件，需要额外安装 Jupyter Lab 插件，更多插件请参考 Jupyter RenderersNotes:查看所安装的插件可以运行 jupyter labextension list卸载某插件可以用 jupyter labextension uninstall，例如：jupyter labextension uninstall @jupyterlab/plotly-extension1.[译] 27 个 Jupyter Notebook的小提示与技巧 | Focus on ML &amp; DM ↩2.Jupyter Notebook的27个秘诀，技巧和快捷键 | 作业部落 Cmd Markdown 编辑阅读器 ↩3.JupyterLab插件 | RexKing6’s Note ↩]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hexo 文字排版全纪录]]></title>
    <url>%2F2019%2F01%2F17%2FHexo%20%E6%8E%92%E7%89%88%E5%85%A8%E7%BA%AA%E5%BD%95%2F</url>
    <content type="text"><![CDATA[再好的表达能力也需要精致的排版技巧为什么使用 Hexo 排版hexo 是使用 Markdown 语言作为主要书写语言，其目的是通过简单、易读易写的文本格式生成结构化的 HTML 文档，所以 Markdown 是兼容 HTML 的。虽然一些基本的语法在各种 Markdown 书写软件是支持的，但是不同的软件支持的广度又不一样，例如 Github Flavored Markdown (GFM) 语法不支持 Markdown 注脚，这会造成易用性的困难，Hexo 可以很好地解决这个排版问题，例如可以通过安装相应的插件实现。这里推荐 Markdown 软件 MWeb，可以很好的支持静态博客的生成，还可以将笔记发布到印象笔记，可以说非常方便。利用 hexo server 进入调试模式，左边网页实时渲染 control+R 刷新，右边 书写 Markdown control+S 保存，必要时可以利用移动设备局域网下访问站点或利用 Chrome 调试成移动端观察渲染效果。Hexo 文章模板文件如果你是在站点文件夹根目录用 hexo new post &lt;title&gt; 新建的文章，那么其实它就是将文章的模版文件 post.md「复制」了一份到 ~/blog/source/_posts/ 下，所以这也意味着：你可以通过命令行的方式创建模板样式的 .md 文件。你可以直接通过在 ~/blog/source/_posts/ 下新建 .md 结尾的文件来写新的文章。为了美观起见，英文和中文之间必须添加空格首先这里附上我的模板文件文件位置：~/hexo/blog/scaffolds/post.md1234567891011121314151617181920212223---title: &#123;&#123; title &#125;&#125;date: &#123;&#123; date &#125;&#125;permalink:categories:tags: []description:mathjax: ---&lt;p class="description"&gt;&lt;/p&gt;&lt;img src="" alt="" style="width:85%" /&gt;&lt;!-- more --&gt;######&lt;hr /&gt;&#123;% note success no-icon %&#125; &lt;center&gt;本文更新于 &lt;/center&gt;&#123;% endnote %&#125;Tips: 这个地方写作时若直接插入上面 Markdown 代码，{{ title }}、{{ date }} 的部分会被转义，所以应该在代码中间插入 {% raw %}{% endraw %} 防止被转义。下面逐一解释上述模板文件以 ---分隔的区域，叫做 Front-matter ，是用于指定此文件所包含的变量，具体变量实现可以百度搜索了解Hexo 会自动识别 &lt;!-- more --&gt; 部分为摘要，也就是表现在首页部分，一般来说，为了美观起见，首页都是一句话加上一张图片排版，这句话写在 &lt;p&gt;&lt;/p&gt; 标签内，src 插入图片的 url 链接。正文中所有的标题都是从二级标题开始。最后插入 &lt;hr /&gt; 横线表示文章结束，从后面可以插入参考文献。最后插入本文的修改时间，技术总是会随着时间更新，提示读者本文的最后修改时间。当然，文章摘要还需要在 _custom.styl 下插入一些自定义 CSS 样式，代码如下：文件位置：~/hexo/blog/themes/next/source/css/_custom/custom.styl12345678910111213141516+ // 文章的描述description+ .posts-expand .post-meta .post-description &#123;+ font-style: italic;+ font-size: 14px;+ margin-top: 30px;+ margin-bottom: 0px;+ color: #666;+ &#125;+ // 自定义替代description的样式+ p.description&#123;+ text-align: center;+ font-size: 14px;+ font-style: italic;+ color: #666;+ margin-top: 30px;+ &#125;红色 - 和绿色 + 的样式哪来的？哈哈哈，原来这也是一种语言，叫 diff，所以你只需在 [language] 这写 diff，然后在相应代码前面加上 - 和 + 就行了。不过默认的 - 是绿色，+ 是红色，与 GitHub 上相反，别扭就自己改成 GitHub 的，在 custom.styl 加入以下代码文件位置：~/hexo/blog/themes/next/source/css/_custom/custom.styl1234567+ // 文章```代码块diff样式+ pre .addition &#123;+ background: #e6ffed;+ &#125;+ pre .deletion &#123;+ background: #ffeef0;+ &#125;段内文字格式Hexo 中基本的 Markdown 语法手册可以参考这篇博文 Hexo Markdown 简明语法手册 | Mobilicorpus，如果有些用 Markdwon 的语法却达不到预期效果（甚至产生奇怪的 bugs），或者用 Markdwon 的语法无法实现，这时就可以考虑用 HTML 和 CSS。下面是比较常见的，难以用 Markdwon 的语法实现的 HTML 语言：样式代码效果分隔线&lt;hr /&gt;引用&lt;blockquote&gt;引用内容&lt;/blockquote&gt;引用内容更宽的引用&lt;p&gt;&lt;blockquote&gt;引用内容&lt;/blockquote&gt;&lt;/p&gt;引用内容居中&lt;center&gt;内容&lt;/center&gt;内容右对齐&lt;p style=&quot;text-align:right&quot;&gt;内容&lt;/p&gt;内容左对齐&lt;p style=&quot;text-align:left&quot;&gt;内容&lt;/p&gt;内容字体大小和颜色1&lt;font color=&quot;red&quot; size=&quot;1&quot;&gt;内容&lt;/font&gt;内容黄色荧光笔&lt;mark&gt;内容&lt;/mark&gt;内容Bootstrap Callout2本站用的是 Next 主题，其配备了一些自带的主题样式，需要在主题配置文件 中开启：文件位置：~/hexo/blog/themes/next/config123456789101112note: # Note tag style values: # - simple bs-callout old alert style. Default. # - modern bs-callout new (v2-v3) alert style. # - flat flat callout style with background, like on Mozilla or StackOverflow. # - disabled disable all CSS styles import of note tag. style: simple icons: false border_radius: 3 # Offset lighter of background in % for modern and flat styles (modern: -12 | 12; flat: -18 | 6). # Offset also applied to label tag variables. This option can work with disabled note tag. light_bg_offset: 0可以获得类似 beamer 中的 block 样式：This is a notenote textnote text代码如下：&#123;% note danger %&#125;#### This is a notenote textnote text&#123;% endnote %&#125; 注意可以在 danger 后面加上 no-icon 实现去掉旁边的 icon，这个地方我用了四级标题 ####，避免歧义，左侧导航栏没有显示，在主题配置文件 toc 选项可以修改，同样，在附上这段代码时,同样加上 {% raw %}{% endraw %}，防止被转义。还有一种 label 样式，所谓的 label 从效果上看神似荧光笔，例如：这是default这是primary这是success这是info这是warning这是danger这是有删除线的danger相应的代码：1234567&#123;% label default@default%&#125;&#123;% label primary@primary%&#125;&#123;% label success@success%&#125;&#123;% label info@info%&#125;&#123;% label warning@warning%&#125;&#123;% label danger@danger%&#125;~~&#123;% label danger@danger%&#125;~~ 代码格式在主题配置文件可以开启代码自动高亮功能，代码按照以下格式给出123&#123;% codeblock [title] [lang:language] [url] [link text] [line_number:(true|false)] [highlight:(true|false)] [first_line:number] [mark:#,#-#] %&#125;YOUR CODE HERE&#123;% endcodeblock %&#125; title 是代码名称，一般为此段代码所在的文件路径；language 是代码语言的名称，用来设置代码块颜色高亮，纯文本用 plain；url 是文件所在的超链接地址；link text 如它的字面意思，超链接的名称；注意：这四个参数都不是必须的，若不指定代码语言开启自动高亮后则会自动为代码高亮更多内置标签插件样式参考 标签插件段间排版对于中文排版，常用的排版方式分为两种，一种是首段空两格，段间距等于行间距，这种方式叫做段首缩排（下图左一）。还有一种是段首不进行缩进，段间距大于行间距，叫做段间距式（下图左二）。书籍印刷的表现要求是专注文字内容，因此阅读体验应当置于美观之上。由于段间距比段首缩排的分离程度更大，一字连一字阅读时易产生隔阂感、停顿感，故段首缩排与之相比更为优雅，有着更好的阅读体验。对于网页，与纸质书的翻页不同，它是竖直方向的连续滚动。当网页快速滚动时，就使段落上下相连的段首缩排显得繁密易懵，而段落上下间隔的段间距则显得结构简明。段首缩排在快速滚动的互联网时代显得混乱与不整齐，段间距也就比段首缩排更适合于网页，因为它更利于快速传达信息。千万不要同时用段首缩排和段间距！(上图右一)，技术类文章用段间距排版（左二），文学类的文章用段首缩排（左一）！$$\mathbb{R}^n$$aaaa1.HTML 标签 | w3school ↩2.Note (Bootstrap Callout) | NexT ↩3.打造个性超赞博客Hexo+NexT+GitHubPages的超深度优化 | reuixiy ↩]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
