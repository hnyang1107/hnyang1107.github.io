<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>HNYANG</title>
  
  <subtitle>「你可知“茴”字有几种写法？」</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://hnyang.me/"/>
  <updated>2019-01-10T14:45:35.716Z</updated>
  <id>https://hnyang.me/</id>
  
  <author>
    <name>Haonan Yang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Pandas 数据清洗</title>
    <link href="https://hnyang.me/2019/01/09/Hello-World-0/"/>
    <id>https://hnyang.me/2019/01/09/Hello-World-0/</id>
    <published>2019-01-09T11:42:36.000Z</published>
    <updated>2019-01-10T14:45:35.716Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Pandas-数据清洗"><a href="#Pandas-数据清洗" class="headerlink" title="Pandas 数据清洗"></a>Pandas 数据清洗</h3><p>本文主要介绍如何查找缺失数据<br><a id="more"></a></p><p>用<code>isnull</code>检查某一列是否为缺失数据<br>例如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.post_id[df.post_id.isnull()]</span><br></pre></td></tr></table></figure></p><p><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fyhtphwtwsj308x06tmx1.jpg" alt=""></p><ul><li>若指定若在整个表中出现缺失，则删除这一行</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.dropna()</span><br></pre></td></tr></table></figure><p><em>若不赋值，则不改变原来的<code>df</code></em></p><ul><li>若只考虑<code>post_id</code>这一列上，只要出现缺失数据则删除改行：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df = df.dropna(subset=[<span class="string">'post_id'</span>])</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Pandas-数据清洗&quot;&gt;&lt;a href=&quot;#Pandas-数据清洗&quot; class=&quot;headerlink&quot; title=&quot;Pandas 数据清洗&quot;&gt;&lt;/a&gt;Pandas 数据清洗&lt;/h3&gt;&lt;p&gt;本文主要介绍如何查找缺失数据&lt;br&gt;
    
    </summary>
    
    
      <category term="Pandas" scheme="https://hnyang.me/tags/Pandas/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://hnyang.me/2019/01/09/hello-world/"/>
    <id>https://hnyang.me/2019/01/09/hello-world/</id>
    <published>2019-01-09T11:20:50.132Z</published>
    <updated>2019-01-09T11:20:50.132Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Git 常用命令总结</title>
    <link href="https://hnyang.me/2018/12/17/Git%20%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/"/>
    <id>https://hnyang.me/2018/12/17/Git 常用命令总结/</id>
    <published>2018-12-17T07:49:31.858Z</published>
    <updated>2019-01-10T14:45:30.954Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、查看最近提交的日志"><a href="#1、查看最近提交的日志" class="headerlink" title="1、查看最近提交的日志"></a>1、查看最近提交的日志</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> --pretty=oneline --abbrev-commit</span><br></pre></td></tr></table></figure><p>可以得到类似下面的输出：<br><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fy9srbu21tj30ob03paax.jpg" alt=""><br>其中左边的表示Git的<code>commit id</code>，是一个SHA1计算出来的一个非常大的数字，用十六进制表示，在<code>Pycharm 2018.3.1 (Community Edition)</code>版本之后，可以在<code>Version Control</code> 中看到时间线：<br><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fy9t24zrnbj30qd04xaax.jpg" alt=""></p><p><strong><em>注意：<code>git log</code>只能看到以当前版本为起点的之前所有版本的信息</em></strong><br><strong><em>想要看到所有的操作记录，使用<code>git reflog</code></em></strong></p><h2 id="2、版本退回"><a href="#2、版本退回" class="headerlink" title="2、版本退回"></a>2、版本退回</h2><p>###2.1 退回历史版本<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard HEAD^</span><br></pre></td></tr></table></figure></p><p><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fy9tjlfcohj30qe04xq3t.jpg" alt=""></p><p><center><small>此时<code>master</code>指向了<code>HEAD^</code></small></center><br>Git必须知道当前版本是哪个版本，在Git中，用<code>HEAD</code>表示当前版本，也就是最新的提交<code>88269a...</code>，上一个版本就是<code>HEAD^</code>，上上一个版本就是<code>HEAD^^</code>，当然往上100个版本写100个<code>^</code>比较容易数不过来，所以写成<code>HEAD~100</code></p><h3 id="2-2-退回未来版本"><a href="#2-2-退回未来版本" class="headerlink" title="2.2 退回未来版本"></a>2.2 退回未来版本</h3><p>首先用<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reflog</span><br></pre></td></tr></table></figure></p><p>找到所有操作的历史记录<br><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fy9ufw7qlbj30mx01zt94.jpg" alt=""><br>左边指的是操作完之后的版本ID，要退回初始版本，则<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard 88269ab4</span><br></pre></td></tr></table></figure></p><p>也可以在<code>Pycharm</code>中可视化操作</p><h2 id="3、分支创建与合并"><a href="#3、分支创建与合并" class="headerlink" title="3、分支创建与合并"></a>3、分支创建与合并</h2><h3 id="3-1-dev分支创建"><a href="#3-1-dev分支创建" class="headerlink" title="3.1 dev分支创建"></a>3.1 <code>dev</code>分支创建</h3><p>一开始的时候，<code>master</code>分支是一条线，Git用<code>master</code>指向最新的提交，再用<code>HEAD</code>指向<code>master</code>，就能确定当前分支，以及当前分支(<code>HEAD</code>分支)的提交点：<br><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fy9vqh1258j308d0473yd.jpg" alt=""></p><p> 当我们创建新的分支，例如dev时，Git新建了一个指针叫<code>dev</code>，指向<code>master</code>相同的提交，再把<code>HEAD</code>指向<code>dev</code>，就表示当前分支在<code>dev</code>上：<br><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fy9w9ew1h7j30a706hwee.jpg" alt=""><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b dev</span><br><span class="line">Switched to a new branch <span class="string">'dev'</span></span><br></pre></td></tr></table></figure></p><p><code>git checkout</code>命令加上<code>-b</code>参数表示创建并切换，相当于以下两条命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git branch dev</span><br><span class="line">$ git checkout dev</span><br><span class="line">Switched to branch <span class="string">'dev'</span></span><br></pre></td></tr></table></figure></p><p>Git创建一个分支很快，因为除了增加一个dev指针，改改HEAD的指向，工作区的文件都没有任何变化！<br>用<code>git branch</code>命令查看当前分支：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">* dev</span><br><span class="line">  master</span><br></pre></td></tr></table></figure></p><hr><h3 id="3-2-分支合并"><a href="#3-2-分支合并" class="headerlink" title="3.2 分支合并"></a>3.2 分支合并</h3><h4 id="3-2-1-Fast-forward-模式"><a href="#3-2-1-Fast-forward-模式" class="headerlink" title="3.2.1 Fast forward 模式"></a>3.2.1 Fast forward 模式</h4><p>从现在开始，对工作区的修改和提交就是针对<code>dev</code>分支了，比如新提交一次后，<code>dev</code>指针往前移动一步，而<code>master</code>指针不变：<br><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fy9wgv7a96j30dq06ha9z.jpg" alt=""><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git add readme.txt </span><br><span class="line">$ git commit -m <span class="string">"branch test"</span></span><br><span class="line">[dev b17d20e] branch <span class="built_in">test</span></span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure></p><p>现在，<code>dev</code>分支的工作完成，我们就可以切换回master分支：<br><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fy9x49ylsgj30bn0663yf.jpg" alt=""><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">Switched to branch <span class="string">'master'</span></span><br></pre></td></tr></table></figure></p><p>假如我们在<code>dev</code>上的工作完成了，就可以把dev合并到master上。最简单的方法，就是直接把<code>master</code>指向<code>dev</code>的当前提交，就完成了合并：<br><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fy9wjymvaaj30br0663yf.jpg" alt=""><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git merge dev</span><br><span class="line">Updating d46f35e..b17d20e</span><br><span class="line">Fast-forward</span><br><span class="line"> readme.txt | 1 +</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure></p><h4 id="3-2-2-禁用Fast-forward模式"><a href="#3-2-2-禁用Fast-forward模式" class="headerlink" title="3.2.2 禁用Fast forward模式"></a>3.2.2 禁用Fast forward模式</h4><p><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fy9yno8rukj30dq06haa1.jpg" alt=""><br>在这种情况下若想保留  <code>dev</code>的信息，则应该用<br><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fy9yopafwsj30dc075web.jpg" alt=""><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git merge --no-ff -m <span class="string">"merge with no-ff"</span> dev</span><br></pre></td></tr></table></figure></p><p>因为生成新的路径，需要<code>commit</code>.</p><hr><h3 id="3-3-分支删除"><a href="#3-3-分支删除" class="headerlink" title="3.3 分支删除"></a>3.3 分支删除</h3><p>合并完分支后，甚至可以删除<code>dev</code>分支。删除<code>dev</code>分支就是把<code>dev</code>指针给删掉，删掉后，我们就剩下了一条<code>master</code>分支：<br><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fy9wmeqxmlj30br04fdfp.jpg" alt=""><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -d dev</span><br><span class="line">Deleted branch dev (was b17d20e).</span><br></pre></td></tr></table></figure></p><h3 id="3-4-分支策略"><a href="#3-4-分支策略" class="headerlink" title="3.4 分支策略"></a>3.4 分支策略</h3><p><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fy9yt6aoe5j30du03ha9w.jpg" alt=""></p><ul><li><code>master</code>分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；</li><li>每个人都在<code>dev</code>分支上干活，每个人都有自己的分支，时不时地往dev分支上合并就可以了；</li></ul><h2 id="4、版本冲突"><a href="#4、版本冲突" class="headerlink" title="4、版本冲突"></a>4、版本冲突</h2><p>如果遇到这种情况<br><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fy9xjvysahj30bt07k3yc.jpg" alt=""><br>则Git无法执行“快速合并”，只能试图把各自的修改合并起来，Git用<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>，<code>=======</code>，<code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code>标记出不同分支的内容，用<code>git status</code>找到冲突文件，需在冲突文件上手动修改<br><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fy9xnf04icj30fb07kmx0.jpg" alt=""><br>这样才解决了冲突，用<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> --graph --pretty=oneline --abbrev-commit</span><br></pre></td></tr></table></figure></p><p>可以看到分支合并情况</p><h2 id="5、基本命令图解"><a href="#5、基本命令图解" class="headerlink" title="5、基本命令图解"></a>5、基本命令图解</h2><p><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fya0kscjvvj30eq0csq41.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1、查看最近提交的日志&quot;&gt;&lt;a href=&quot;#1、查看最近提交的日志&quot; class=&quot;headerlink&quot; title=&quot;1、查看最近提交的日志&quot;&gt;&lt;/a&gt;1、查看最近提交的日志&lt;/h2&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Docker常用命令总结</title>
    <link href="https://hnyang.me/2018/12/16/5.%20Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/"/>
    <id>https://hnyang.me/2018/12/16/5. Docker常用命令总结/</id>
    <published>2018-12-16T12:43:05.598Z</published>
    <updated>2019-01-13T08:06:50.125Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、Docker简介"><a href="#1、Docker简介" class="headerlink" title="1、Docker简介"></a>1、Docker简介</h2><p>下面的图片比较了 Docker 和传统虚拟化方式的不同之处。传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程；而容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核，而且也没有进行硬件虚拟。因此容器要比传统虚拟机更为轻便。</p><p><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fy8w25e23fj30j8079my5.jpg" alt=""><br><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fy8w3pug5oj30j505f75a.jpg" alt=""></p><h2 id="2、获取镜像"><a href="#2、获取镜像" class="headerlink" title="2、获取镜像"></a>2、获取镜像</h2><p>从 Docker 镜像仓库获取镜像的命令是 <code>docker pull</code>。其命令格式为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签]</span><br></pre></td></tr></table></figure><p>上大校内可以搭建私人镜像仓库，方便的在校内搭建docker环境，镜像仓库<code>mirrors.hoc.ccshu.net</code>位于校内网络， 已经启用<code>HTTPS</code>，校内用户的电脑无需进行配置，连上校园网即可进行访问。</p><p>例如：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull hub.hoc.ccshu.net/project/buptbbsspider:latest</span><br></pre></td></tr></table></figure></p><p>对于 Docker Hub，如果不给出用户名，则默认为 <code>library</code>，也就是官方镜像。</p><h2 id="3、查看镜像"><a href="#3、查看镜像" class="headerlink" title="3、查看镜像"></a>3、查看镜像</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure><h2 id="4、删除镜像"><a href="#4、删除镜像" class="headerlink" title="4、删除镜像"></a>4、删除镜像</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi hello-world</span><br></pre></td></tr></table></figure><h2 id="3、运行docker"><a href="#3、运行docker" class="headerlink" title="3、运行docker"></a>3、运行docker</h2><p>有了镜像后，我们就能够以这个镜像为基础启动并运行一个容器（可以理解为一个Linux系统），例如：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --rm hnyang/buptbbsspider /bin/bash</span><br></pre></td></tr></table></figure></p><ul><li><code>-it</code>：这是两个参数，一个是 <code>-i</code>：交互式操作，一个是 <code>-t</code> 终端。我们这里打算进入 bash 执行一些命令并查看返回结果，因此我们需要交互式终端。</li><li><code>--rm</code>：这个参数是说容器退出后随之将其删除。默认情况下，为了排障需求，退出的容器并不会立即删除，除非手动 <code>docker rm</code>。我们这里只是随便执行个命令，看看结果，不需要排障和保留结果，因此使用 <code>--rm</code> 可以避免浪费空间。</li><li>也可以添加参数 <code>-d</code>使其后台运行，返回其容器ID（再进入容器用<code>docker attach 容器ID</code>）</li></ul><p><em><strong>注意：</strong></em></p><p>就算使用了 <code>-d</code> 参数 然后用<code>attach</code>命令返回容器，再次用 <code>exit</code> 命令退出时，容器还是会删除，所以<strong>如果想要容器正常退出不关闭容器，请按 <code>Ctrl+P+Q</code> 进行退出容器</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1、Docker简介&quot;&gt;&lt;a href=&quot;#1、Docker简介&quot; class=&quot;headerlink&quot; title=&quot;1、Docker简介&quot;&gt;&lt;/a&gt;1、Docker简介&lt;/h2&gt;&lt;p&gt;下面的图片比较了 Docker 和传统虚拟化方式的不同之处。传统虚拟机技术是
      
    
    </summary>
    
    
  </entry>
  
</feed>
